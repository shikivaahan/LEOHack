# Introduction

This repository holds the basic code for interfacing with the Active Satellite Robot (ASR) from your laptop. It is there to serve a baseline for you to connect to the Arduino and control the motors of the robot.

## System overview

The robot's onboard computer (the Arduino Nano IOT) is a microcontroller running on C++ compiled code. It has a WiFi/Bluetooth module on it and that's what is used to connect to it. The Nano creates its own network to which the ground station (laptop running python) is connected. The python script on the laptop then takes button presses from the user and transmits them as single characters which the Arduino then receives and triggers the corresponding functions.

# Installation Instructions

## Software Download

To edit, compile and run the code you will need two IDE environments. (In theory we could do only one, but it'll be easier if we use two separate ones).
- Arduino IDE
- VSCode (or any other python IDE like Spyder)

### Arduino IDE

To download Arduino IDE, use this link: https://www.arduino.cc/en/software/
If you're new to Arduino (then you're in for a treat!), follow this link for a basic getting-started guide: https://docs.arduino.cc/software/ide-v2/tutorials/getting-started-ide-v2/

Go to Tools/Manage Libraries and download *WiFiNINA* library.

### VS Code

VS Code is a very popular developer software for all types of languages. If you already have an IDE ready, feel free to use it. If not, download VS Code from here: https://code.visualstudio.com/download.

Next, you will need to install python and its dependencies (python add-ons). The exact steps will differ based on your operating system so please follow the steps outlined on this page to install python, and a python VS Code extension: https://code.visualstudio.com/docs/python/python-tutorial#_prerequisites

## Downloading the code

For quick-start, just download the repo from this webpage (top right button). Save it and start working in it. However it is recommended you fork this repository into your private GitHub (or equivalent) repository and work there. It is also totally fine if you don't want to use this code at all and start something from scratch.


# Running the code

## Arduino IDE

The robot's onboard computer runs on 'onboard_receiver.ino' code which uses the surrounding files in the 'onboard_receiver' folder. Open it with Arduino IDE. Towards the top, you will see:
```
char ssid[] = "Nano_[YOUR_NAME]_AP";
char pass[] = "nano1pwd";
```
This will be the name of your Nano's WiFi. Change the ssid so it includes your name in it, also change the password to something you prefer (8 characters minimum). Plug in the board and hit the 'upload' button to upload the code. It should start running straight away!

## Python Script

First, connect your laptop to the WiFi network created by your nano. Then, run the 'remote_control.py' file to start up the controller. If everything works, it should connect to your Arduino in a few seconds. Then you can use the following buttons to control the robot:
w -> go foward
s -> go backwards
q -> rotate left
e -> rotate right

And voilla! You are controlling the robot. Now you can make your own modifications to it :) 

## Real-Time AprilTag Tracking & Recording

The script `src/qr_stream_app.py` provides real-time video ingestion, AprilTag detection, pose estimation (yaw/pitch/roll), and bearing calculation relative to the camera optical axis. It overlays diagnostics, draws a center crosshair, and can record annotated video for debugging.

### Features

- Stream from local webcam (index), HTTP/RTSP URL, or video file path.
- AprilTag detection using OpenCV ArUco AprilTag dictionaries (e.g. 36h11).
- Crosshair overlay at frame center.
- Pose estimation of the tag plane via `solvePnP` (uses IPPE square when available).
- Bearing (angular offset) from center in X and Y.
- Per-frame overlay of orientation, bearing, and tag id.
- Optional mirroring for operator-friendly display.
- Adjustable assumed horizontal Field Of View (FOV) if camera specs differ.
- Video recording with common codecs fallback logic.

### Installation (Python Dependencies)

From the repository root inside your virtual environment:

```pwsh
pip install opencv-python numpy
```

### Usage Examples

Webcam (default index 0):

```pwsh
python src/qr_stream_app.py --url 0 --display --record --tag-family 36h11 --tag-size 0.10
```

HTTP/RTSP stream:

```pwsh
python src/qr_stream_app.py --url http://192.168.0.10:8080/video --fov 65 --record --tag-size 0.10
```

Video file for offline processing:

```pwsh
python src/qr_stream_app.py --url sample_clip.mp4 --no-display --out processed_clip --record --tag-size 0.10
```

If you want to disable recording entirely:

```pwsh
python src/qr_stream_app.py --url 0 --no-record
```

Adjust QR physical size (edge length meters) for more accurate pose:

```pwsh
python src/qr_stream_app.py --url 0 --tag-size 0.08
```

Mirror the view (useful for operator perspective):

```pwsh
python src/qr_stream_app.py --url 0 --mirror
```

### Notes on Pose & Bearing

Pose estimation assumes a pinhole camera model with focal length inferred from the provided horizontal FOV. If your camera FOV differs, pass `--fov` for better angular accuracy. The AprilTag 3D model is a flat square lying on Z=0 plane, centered at origin; IPPE improves stability for planar patterns when available.

Bearing angles are computed by projecting pixel offsets from the image center through the focal length. They are approximate if lens distortion is significant (we assume negligible distortion). For refined results, integrate a calibration step to obtain accurate `fx`, `fy`, `cx`, `cy`, and distortion coefficients.

### Performance Tips

- Reduce frame width with `--max-width` to sustain real-time FPS on lower hardware.
- Disable display (`--no-display`) when you only need recording for higher throughput.
- Use a smaller `--font-scale` to reduce overlay drawing cost.

### Exit

Press `q` or `Esc` in the display window to terminate gracefully.

### Future Extensions (Ideas)

- Add camera calibration loading from YAML.
- Publish measurements over a socket/UDP for downstream control.
- Implement tracking smoothing and lost-target timeout.
- Add ArUco fallback for more robust pose when QR decoding fails.

## Breakout Board Pinout

- Black -> GND (3A max)
- Red -> +5V (3A max)
- Yellow -> D9 (PWM/White-Blue Cable)
- Orange -> D11 (PWM/White-Orange Cable)
- Brown -> D12 (PWM/White-Brown Cable)
- White -> A0 (Anaolgue/White-Green Cable)
- Grey -> +3.3V (150 mA max/Blue Cable)
- Purple -> A2 (Analogue/Green Cable)
